<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatro</title>
    <style>
        :root {
            --bg-body: linear-gradient(135deg, #e0e7ff, #f3e8ff);
            --bg-container: white;
            --text-color: #333;
            --header-bg: linear-gradient(90deg, #075e54, #128c7e);
            --msg-sent-bg: #dcf8c6;
            --msg-received-bg: white;
            --msg-received-border: 1px solid #e0e0e0;
            --input-bg: #fff;
            --input-border: 1px solid #ddd;
            --status-bg: #f0f0f0;
            --status-text: #555;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            --peer-list-bg: #fafafa;
            --download-button-bg: #4CAF50;
            --download-button-hover: #45a049;
        }
        [data-theme="dark"] {
            --bg-body: linear-gradient(135deg, #2c2c2c, #3e3e3e);
            --bg-container: #1e1e1e;
            --text-color: #e0e0e0;
            --header-bg: linear-gradient(90deg, #054d44, #0a7066);
            --msg-sent-bg: #2a5f2a;
            --msg-received-bg: #2e2e2e;
            --msg-received-border: 1px solid #444;
            --input-bg: #2e2e2e;
            --input-border: 1px solid #555;
            --status-bg: #252525;
            --status-text: #bbb;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            --peer-list-bg: #252525;
            --download-button-bg: #388E3C;
            --download-button-hover: #2e7d32;
        }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--bg-body);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-color);
        }
        .chat-container {
            width: 90%;
            max-width: 900px;
            margin: 20px;
            background: var(--bg-container);
            border-radius: 15px;
            box-shadow: var(--shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .chat-header {
            background: var(--header-bg);
            color: white;
            padding: 10px 15px;
            text-align: center;
            font-size: clamp(1.2em, 4vw, 1.5em);
            font-weight: 600;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        #username-input {
            padding: 8px;
            border: none;
            border-radius: 5px;
            font-size: clamp(0.9em, 3vw, 1em);
            width: 100%;
            max-width: 200px;
            margin: 5px 0;
            background: var(--input-bg);
            color: var(--text-color);
        }
        .chat-messages {
            flex: 1;
            max-height: 50vh;
            overflow-y: auto;
            padding: 15px;
            background: var(--bg-container);
        }
        .message {
            margin: 8px 0;
            padding: 10px 15px;
            border-radius: 10px;
            max-width: 80%;
            animation: slideIn 0.3s ease;
            font-size: clamp(0.9em, 3vw, 1em);
            color: var(--text-color);
        }
        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .sent {
            background: var(--msg-sent-bg);
            margin-left: auto;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .received {
            background: var(--msg-received-bg);
            border: var(--msg-received-border);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        .chat-input {
            display: flex;
            padding: 10px;
            background: var(--bg-container);
            border-top: var(--msg-received-border);
            gap: 8px;
            flex-wrap: wrap;
        }
        #message-input {
            flex-grow: 1;
            padding: 10px;
            border: var(--input-border);
            border-radius: 20px;
            font-size: clamp(0.9em, 3vw, 1em);
            transition: border-color 0.3s;
            background: var(--input-bg);
            color: var(--text-color);
        }
        #message-input:focus {
            border-color: #075e54;
            outline: none;
        }
        #send-button, #call-button, #end-call-button, #file-button {
            padding: 10px 15px;
            background: #075e54;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #send-button:hover, #call-button:hover, #end-call-button:hover, #file-button:hover {
            background: #054d44;
        }
        #end-call-button {
            background: #f44336;
            display: none;
        }
        #end-call-button:hover {
            background: #d32f2f;
        }
        #file-input {
            display: none;
        }
        .download-button {
            padding: 5px 10px;
            background: var(--download-button-bg);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 5px;
            display: inline-block;
            transition: background 0.3s;
        }
        .download-button:hover {
            background: var(--download-button-hover);
        }
        .status {
            padding: 8px;
            text-align: center;
            color: var(--status-text);
            font-size: clamp(0.8em, 2.5vw, 0.9em);
            background: var(--status-bg);
        }
        .connection-controls {
            padding: 15px;
            background: var(--bg-container);
            border-top: var(--msg-received-border);
        }
        .connection-controls label {
            display: block;
            margin: 8px 0 4px;
            color: var(--text-color);
            font-weight: 500;
            font-size: clamp(0.9em, 3vw, 1em);
        }
        #peer-id, #remote-id, #peer-name {
            width: 100%;
            padding: 8px;
            border: var(--input-border);
            border-radius: 8px;
            font-size: clamp(0.9em, 3vw, 1em);
            margin-bottom: 5px;
            background: var(--input-bg);
            color: var(--text-color);
        }
        #copy-button, #connect-button, #disconnect-button, #theme-toggle {
            padding: 8px;
            margin: 5px 5px 0 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
        }
        #copy-button {
            background: #4CAF50;
            color: white;
        }
        #copy-button:hover {
            background: #45a049;
            transform: scale(1.05);
        }
        #connect-button {
            background: #2196F3;
            color: white;
        }
        #connect-button:hover {
            background: #1976D2;
            transform: scale(1.05);
        }
        #disconnect-button {
            background: #f44336;
            color: white;
            display: none;
        }
        #disconnect-button:hover {
            background: #d32f2f;
            transform: scale(1.05);
        }
        #theme-toggle {
            background: #666;
            color: white;
        }
        #theme-toggle:hover {
            background: #555;
            transform: scale(1.05);
        }
        #peer-list {
            max-height: 20vh;
            overflow-y: auto;
            margin: 10px 0;
            border: var(--input-border);
            border-radius: 8px;
            padding: 8px;
            background: var(--peer-list-bg);
        }
        .peer-item {
            cursor: pointer;
            padding: 6px;
            border-radius: 5px;
            transition: background 0.2s;
            font-size: clamp(0.9em, 3vw, 1em);
            color: var(--text-color);
        }
        .peer-item.online {
            color: #2e7d32;
        }
        .peer-item.offline {
            color: #d32f2f;
        }
        .peer-item:hover {
            background: #e0f7fa;
        }
        @media (max-width: 600px) {
            .chat-container {
                margin: 10px;
            }
            .chat-header {
                padding: 8px 10px;
                flex-direction: column;
            }
            #username-input {
                width: 100%;
                max-width: none;
            }
            .chat-messages {
                padding: 10px;
            }
            .chat-input {
                padding: 8px;
                flex-wrap: wrap;
            }
            #message-input {
                margin-right: 5px;
            }
            #send-button, #call-button, #end-call-button, #file-button {
                padding: 8px 12px;
            }
            .connection-controls {
                padding: 10px;
            }
            #peer-id, #remote-id, #peer-name {
                max-width: none;
            }
            #copy-button, #connect-button, #disconnect-button, #theme-toggle {
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h2>Chatro</h2>
            <input type="text" id="username-input" placeholder="Set your username">
        </div>
        <div class="status" id="status">Checking connection...</div>
        <div class="chat-messages" id="chat-messages"></div>
        <div class="chat-input">
            <input type="text" id="message-input" placeholder="Type a message...">
            <button id="send-button">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                </svg>
            </button>
            <button id="file-button">Send File</button>
            <input type="file" id="file-input" accept="*/*">
            <button id="call-button">Start Call</button>
            <button id="end-call-button">End Call</button>
        </div>
        <div class="connection-controls">
            <label>Your Chatro ID: <input type="text" id="peer-id" readonly></label>
            <button id="copy-button">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
            </button>
            <button id="theme-toggle">Toggle Dark Mode</button><br>
            <label>Connect to ID: <input type="text" id="remote-id" placeholder="Enter other user's Peer ID"></label>
            <label>Name: <input type="text" id="peer-name" placeholder="Enter a name for this peer"></label>
            <button id="connect-button">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07L1.71 14.29a1 1 0 0 0 0 1.42l7.07 7.07a1 1 0 0 0 1.42 0L22.29 10.71"></path>
                </svg>
            </button>
            <button id="disconnect-button">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <path d="M10 14 2 22m20-20L10 14"></path>
                </svg>
            </button>
            <div id="peer-list"></div>
        </div>
    </div>

    <!-- PeerJS Library -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
        // DOM elements
        const chatMessages = document.getElementById('chat-messages');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const fileButton = document.getElementById('file-button');
        const fileInput = document.getElementById('file-input');
        const callButton = document.getElementById('call-button');
        const endCallButton = document.getElementById('end-call-button');
        const status = document.getElementById('status');
        const peerIdInput = document.getElementById('peer-id');
        const remoteIdInput = document.getElementById('remote-id');
        const peerNameInput = document.getElementById('peer-name');
        const connectButton = document.getElementById('connect-button');
        const disconnectButton = document.getElementById('disconnect-button');
        const copyButton = document.getElementById('copy-button');
        const peerList = document.getElementById('peer-list');
        const usernameInput = document.getElementById('username-input');
        const themeToggle = document.getElementById('theme-toggle');

        // Load or set username from localStorage
        let currentUser = localStorage.getItem('chatUsername') || '';
        if (!currentUser) {
            currentUser = `User_${Math.random().toString(36).substr(2, 5)}`;
            localStorage.setItem('chatUsername', currentUser);
        }
        usernameInput.value = currentUser;

        // Load messages from localStorage
        let messages = JSON.parse(localStorage.getItem('chatMessages')) || [];
        let peer;
        let conn;
        let isOnline = navigator.onLine;
        let peerStatus = {};
        let localStream;
        let call;
        let audioContext;
        let sourceNode;
        let filterNode;

        // Encode text to prevent XSS
        function encodeHTML(text) {
            return text
                .replace(/&/g, '&')
                .replace(/</g, '<')
                .replace(/>/g, '>')
                .replace(/"/g, '"')
                .replace(/'/g, ''');
        }

        // SHA-256 hashing function
        async function sha256(message) {
            const msgBuffer = new TextEncoder().encode(message);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Update username on input change
        usernameInput.addEventListener('change', () => {
            currentUser = encodeHTML(usernameInput.value.trim()) || `User_${Math.random().toString(36).substr(2, 5)}`;
            localStorage.setItem('chatUsername', currentUser);
            addMessage(`Username updated to "${currentUser}"`, 'System', false);
        });

        // Load or generate persistent PeerJS ID
        let myPeerId = localStorage.getItem('myPeerId');
        if (!myPeerId) {
            myPeerId = `${Math.random().toString(36).substr(2, 9)}-${Date.now()}`;
            localStorage.setItem('myPeerId', myPeerId);
        }

        // Load peer list from localStorage
        let knownPeers = JSON.parse(localStorage.getItem('knownPeers')) || {};

        // Add message to chat and localStorage
        function addMessage(text, sender, isSent, verified = true, isFile = false, fileData = null, fileName = '') {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            messageDiv.classList.add(isSent ? 'sent' : 'received');
            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            if (isFile && fileData) {
                if (fileName.match(/\.(jpg|jpeg|png|gif)$/i)) {
                    const img = document.createElement('img');
                    img.src = fileData;
                    img.style.maxWidth = '100%';
                    messageDiv.appendChild(img);
                    messageDiv.innerHTML += `<br><strong>${encodeHTML(sender)}</strong> (${encodeHTML(time)}): Sent image "${encodeHTML(fileName)}"`;
                } else {
                    messageDiv.innerHTML = `<strong>${encodeHTML(sender)}</strong> (${encodeHTML(time)}): Sent file "${encodeHTML(fileName)}"`;
                }
                const downloadButton = document.createElement('button');
                downloadButton.classList.add('download-button');
                downloadButton.textContent = 'Download';
                downloadButton.onclick = () => {
                    const link = document.createElement('a');
                    link.href = fileData;
                    link.download = fileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                };
                messageDiv.appendChild(downloadButton);
            } else {
                messageDiv.innerHTML = `<strong>${encodeHTML(sender)}</strong> (${encodeHTML(time)}): ${encodeHTML(text)}${!verified ? ' [Integrity check failed]' : ''}`;
            }
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            messages.push({ text: isFile ? `Sent file: ${fileName}` : text, sender, time, isSent, isFile });
            localStorage.setItem('chatMessages', JSON.stringify(messages));
        }

        // Load existing messages
        function loadMessages() {
            messages = JSON.parse(localStorage.getItem('chatMessages')) || [];
            chatMessages.innerHTML = '';
            messages.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message');
                messageDiv.classList.add(msg.isSent ? 'sent' : 'received');
                messageDiv.innerHTML = `<strong>${encodeHTML(msg.sender)}</strong> (${encodeHTML(msg.time)}): ${encodeHTML(msg.text)}`;
                chatMessages.appendChild(messageDiv);
            });
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Send text message with SHA-256 hash
        async function sendMessage() {
            const text = messageInput.value.trim();
            if (text) {
                const hash = await sha256(text);
                const data = JSON.stringify({ type: 'text', sender: currentUser, text, hash });
                if (isOnline && conn && conn.open) {
                    conn.send(data);
                    addMessage(text, currentUser, true);
                } else {
                    addMessage(text, currentUser, true);
                    if (!isOnline) {
                        addMessage('You are offline. Message saved locally.', 'System', false);
                    }
                }
                messageInput.value = '';
            }
        }

        // Send file
        async function sendFile(file) {
            const reader = new FileReader();
            reader.onload = async () => {
                const fileData = reader.result; // ArrayBuffer
                const fileName = file.name;
                const hash = await sha256(fileData); // Hash the file content
                const data = JSON.stringify({ 
                    type: 'file', 
                    sender: currentUser, 
                    fileName, 
                    fileData: Array.from(new Uint8Array(fileData)), // Convert to array for JSON
                    hash 
                });
                if (isOnline && conn && conn.open) {
                    conn.send(data);
                    addMessage(`Sent file: ${fileName}`, currentUser, true, true, true, URL.createObjectURL(file), fileName);
                    addMessage('File sent successfully!', 'System', false);
                } else {
                    addMessage(`File "${fileName}" saved locally (offline).`, currentUser, true, true, true, URL.createObjectURL(file), fileName);
                    if (!isOnline) {
                        addMessage('You are offline. File saved locally.', 'System', false);
                    }
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // Handle file input change
        fileInput.addEventListener('change', () => {
            const file = fileInput.files[0];
            if (file) {
                sendFile(file);
                fileInput.value = ''; // Reset input
            }
        });

        // Trigger file input click
        fileButton.addEventListener('click', () => {
            fileInput.click();
        });

        // Start audio call with noise reduction
        async function startCall() {
            if (!isOnline || !conn || !conn.open) {
                addMessage('Cannot start call while offline or not connected.', 'System', false);
                return;
            }

            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                sourceNode = audioContext.createMediaStreamSource(localStream);
                filterNode = audioContext.createBiquadFilter();
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 3000;
                sourceNode.connect(filterNode);
                filterNode.connect(audioContext.destination);

                const filteredStream = audioContext.createMediaStreamDestination().stream;
                sourceNode.connect(audioContext.createMediaStreamDestination());
                call = peer.call(conn.peer, filteredStream);

                call.on('stream', (remoteStream) => {
                    const audio = new Audio();
                    audio.srcObject = remoteStream;
                    audio.play();
                    addMessage('Call started!', 'System', false);
                    endCallButton.style.display = 'inline-block';
                    callButton.disabled = true;
                });
                call.on('close', () => {
                    endCall();
                });
                call.on('error', (err) => {
                    console.error('Call error:', err);
                    addMessage('Call error: ' + err.message, 'System', false);
                    endCall();
                });
            } catch (err) {
                console.error('Media error:', err);
                addMessage('Failed to access microphone: ' + err.message, 'System', false);
            }
        }

        // End audio call
        function endCall() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (call) {
                call.close();
                call = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
                sourceNode = null;
                filterNode = null;
            }
            addMessage('Call ended.', 'System', false);
            endCallButton.style.display = 'none';
            callButton.disabled = !isOnline || !conn || !conn.open;
        }

        // Update peer list UI with online status
        function updatePeerList() {
            peerList.innerHTML = '';
            for (const [id, name] of Object.entries(knownPeers)) {
                const peerItem = document.createElement('div');
                peerItem.classList.add('peer-item');
                peerItem.classList.add(peerStatus[id] ? 'online' : 'offline');
                peerItem.innerHTML = `${encodeHTML(name)} (${encodeHTML(id)}) - ${peerStatus[id] ? 'Online' : 'Offline'}`;
                peerItem.addEventListener('click', () => {
                    remoteIdInput.value = id;
                    peerNameInput.value = name;
                    connectButton.click();
                });
                peerList.appendChild(peerItem);
            }
        }

        // Check peer online status
        function checkPeerStatus() {
            if (!isOnline || !peer) return;
            for (const id in knownPeers) {
                if (id !== myPeerId && (!conn || conn.peer !== id)) {
                    const tempConn = peer.connect(id, { metadata: { name: currentUser, ping: true } });
                    tempConn.on('open', () => {
                        peerStatus[id] = true;
                        tempConn.close();
                        updatePeerList();
                    });
                    tempConn.on('error', () => {
                        peerStatus[id] = false;
                        updatePeerList();
                    });
                } else if (conn && conn.peer === id && conn.open) {
                    peerStatus[id] = true;
                } else {
                    peerStatus[id] = false;
                }
            }
        }

        // Update online/offline status
        function updateStatus() {
            isOnline = navigator.onLine;
            status.textContent = isOnline ? 'Online' : 'Offline';
            connectButton.disabled = !isOnline || (conn && conn.open);
            disconnectButton.style.display = (isOnline && conn && conn.open) ? 'inline-block' : 'none';
            messageInput.disabled = false;
            sendButton.disabled = false;
            fileButton.disabled = !isOnline || !conn || !conn.open;
            callButton.disabled = !isOnline || !conn || !conn.open || (call && call.open);
            endCallButton.style.display = (call && call.open) ? 'inline-block' : 'none';
            if (!isOnline) {
                addMessage('You are offline. You can still write messages or save files locally.', 'System', false);
            } else {
                addMessage('You are back online!', 'System', false);
                checkPeerStatus();
            }
        }

        // Initialize PeerJS with persistent ID (if online)
        if (isOnline) {
            peer = new Peer(myPeerId);
            peer.on('open', (id) => {
                peerIdInput.value = id;
                status.textContent = 'Online';
                addMessage('Welcome! Please set your username in the header above.', 'System', false);
                addMessage('Share your Peer ID with someone to chat!', 'System', false);
                console.log('Peer ID:', id);
                loadMessages();
                updatePeerList();
                setInterval(checkPeerStatus, 30000);
            });

            peer.on('call', (incomingCall) => {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then((stream) => {
                        localStream = stream;
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        sourceNode = audioContext.createMediaStreamSource(localStream);
                        filterNode = audioContext.createBiquadFilter();
                        filterNode.type = 'lowpass';
                        filterNode.frequency.value = 3000;
                        sourceNode.connect(filterNode);
                        filterNode.connect(audioContext.destination);

                        const filteredStream = audioContext.createMediaStreamDestination().stream;
                        sourceNode.connect(audioContext.createMediaStreamDestination());

                        call = incomingCall;
                        call.answer(filteredStream);
                        call.on('stream', (remoteStream) => {
                            const audio = new Audio();
                            audio.srcObject = remoteStream;
                            audio.play();
                            addMessage('Call received and answered!', 'System', false);
                            endCallButton.style.display = 'inline-block';
                            callButton.disabled = true;
                        });
                        call.on('close', () => {
                            endCall();
                        });
                        call.on('error', (err) => {
                            console.error('Call error:', err);
                            addMessage('Call error: ' + err.message, 'System', false);
                            endCall();
                        });
                    })
                    .catch((err) => {
                        console.error('Media error:', err);
                        addMessage('Failed to answer call: ' + err.message, 'System', false);
                    });
            });
        } else {
            peerIdInput.value = myPeerId;
            status.textContent = 'Offline';
            addMessage('You are offline. Set your username and write messages or save files locally.', 'System', false);
            loadMessages();
            updatePeerList();
        }

        // Handle incoming connections
        if (peer) {
            peer.on('connection', (connection) => {
                if (connection.metadata?.ping) {
                    peerStatus[connection.peer] = true;
                    connection.close();
                    updatePeerList();
                    return;
                }
                conn = connection;
                setupConnection();
                const peerName = conn.metadata?.name || 'Unknown';
                knownPeers[conn.peer] = peerName;
                localStorage.setItem('knownPeers', JSON.stringify(knownPeers));
                updatePeerList();
                addMessage(`Incoming connection from ${peerName} (${conn.peer})`, 'System', false);
            });
        }

        // Connect to another peer
        connectButton.addEventListener('click', () => {
            if (!isOnline) {
                addMessage('Cannot connect while offline.', 'System', false);
                return;
            }
            const remoteId = remoteIdInput.value.trim();
            const peerName = encodeHTML(peerNameInput.value.trim()) || 'Unknown';
            if (remoteId && remoteId !== myPeerId) {
                conn = peer.connect(remoteId, { metadata: { name: currentUser } });
                if (!knownPeers[remoteId] || knownPeers[remoteId] === 'Unknown') {
                    knownPeers[remoteId] = peerName;
                }
                localStorage.setItem('knownPeers', JSON.stringify(knownPeers));
                setupConnection();
                updatePeerList();
            }
        });

        // Disconnect from peer
        disconnectButton.addEventListener('click', () => {
            if (conn && conn.open) {
                conn.close();
                endCall();
                status.textContent = 'Online';
                messageInput.disabled = false;
                sendButton.disabled = false;
                fileButton.disabled = false;
                callButton.disabled = false;
                connectButton.disabled = false;
                disconnectButton.style.display = 'none';
                addMessage('You disconnected from the peer', 'System', false);
                checkPeerStatus();
            }
        });

        // Setup connection handlers
        function setupConnection() {
            conn.on('open', () => {
                status.textContent = 'Connected to ' + conn.peer;
                messageInput.disabled = false;
                sendButton.disabled = false;
                fileButton.disabled = false;
                callButton.disabled = false;
                connectButton.disabled = true;
                disconnectButton.style.display = 'inline-block';
                addMessage('Connected to peer!', 'System', false);
                peerStatus[conn.peer] = true;
                updatePeerList();
                if (conn.metadata?.name) {
                    knownPeers[conn.peer] = conn.metadata.name;
                    localStorage.setItem('knownPeers', JSON.stringify(knownPeers));
                    updatePeerList();
                }
            });

            conn.on('data', async (data) => {
                const parsedData = JSON.parse(data);
                if (parsedData.type === 'text') {
                    const { sender, text, hash } = parsedData;
                    const computedHash = await sha256(text);
                    const isVerified = computedHash === hash;
                    addMessage(text, sender, false, isVerified);
                    if (!isVerified) {
                        addMessage('Warning: Message integrity check failed!', 'System', false);
                    }
                } else if (parsedData.type === 'file') {
                    const { sender, fileName, fileData, hash } = parsedData;
                    const fileBuffer = new Uint8Array(fileData).buffer;
                    const computedHash = await sha256(fileBuffer);
                    const isVerified = computedHash === hash;
                    const blob = new Blob([fileBuffer], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    addMessage(`Received file: ${fileName}`, sender, false, isVerified, true, url, fileName);
                    if (!isVerified) {
                        addMessage('Warning: File integrity check failed!', 'System', false);
                    } else {
                        addMessage('File received successfully!', 'System', false);
                    }
                }
            });

            conn.on('close', () => {
                status.textContent = 'Online';
                messageInput.disabled = false;
                sendButton.disabled = false;
                fileButton.disabled = false;
                callButton.disabled = false;
                connectButton.disabled = false;
                disconnectButton.style.display = 'none';
                endCall();
                addMessage('Peer disconnected', 'System', false);
                peerStatus[conn.peer] = false;
                updatePeerList();
            });

            conn.on('error', (err) => {
                console.error('Connection error:', err);
                status.textContent = 'Error: ' + err.message;
                peerStatus[conn.peer] = false;
                updatePeerList();
            });
        }

        // Copy Peer ID to clipboard
        copyButton.addEventListener('click', () => {
            peerIdInput.select();
            navigator.clipboard.writeText(peerIdInput.value)
                .then(() => {
                    addMessage('Peer ID copied to clipboard!', 'System', false);
                })
                .catch((err) => {
                    console.error('Failed to copy:', err);
                    addMessage('Failed to copy ID', 'System', false);
                });
        });

        // Event listeners for sending messages and call controls
        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
        callButton.addEventListener('click', startCall);
        endCallButton.addEventListener('click', endCall);

        // Handle PeerJS errors
        if (peer) {
            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                status.textContent = 'Error: ' + err.type;
            });
        }

        // Online/offline event listeners
        window.addEventListener('online', () => {
            isOnline = true;
            if (!peer) {
                peer = new Peer(myPeerId);
                peer.on('open', (id) => {
                    peerIdInput.value = id;
                    updateStatus();
                    updatePeerList();
                    setInterval(checkPeerStatus, 30000);
                });
                peer.on('connection', (connection) => {
                    if (connection.metadata?.ping) {
                        peerStatus[connection.peer] = true;
                        connection.close();
                        updatePeerList();
                        return;
                    }
                    conn = connection;
                    setupConnection();
                });
                peer.on('call', (incomingCall) => {
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then((stream) => {
                            localStream = stream;
                            audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            sourceNode = audioContext.createMediaStreamSource(localStream);
                            filterNode = audioContext.createBiquadFilter();
                            filterNode.type = 'lowpass';
                            filterNode.frequency.value = 3000;
                            sourceNode.connect(filterNode);
                            filterNode.connect(audioContext.destination);

                            const filteredStream = audioContext.createMediaStreamDestination().stream;
                            sourceNode.connect(audioContext.createMediaStreamDestination());

                            call = incomingCall;
                            call.answer(filteredStream);
                            call.on('stream', (remoteStream) => {
                                const audio = new Audio();
                                audio.srcObject = remoteStream;
                                audio.play();
                                addMessage('Call received and answered!', 'System', false);
                                endCallButton.style.display = 'inline-block';
                                callButton.disabled = true;
                            });
                            call.on('close', () => {
                                endCall();
                            });
                            call.on('error', (err) => {
                                console.error('Call error:', err);
                                addMessage('Call error: ' + err.message, 'System', false);
                                endCall();
                            });
                        })
                        .catch((err) => {
                            console.error('Media error:', err);
                            addMessage('Failed to answer call: ' + err.message, 'System', false);
                        });
                });
            }
            updateStatus();
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            if (conn) conn.close();
            if (peer) peer.destroy();
            peer = null;
            conn = null;
            endCall();
            updateStatus();
        });

        // Theme toggle
        themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            if (currentTheme === 'dark') {
                document.documentElement.removeAttribute('data-theme');
                localStorage.setItem('theme', 'light');
                themeToggle.textContent = 'Toggle Dark Mode';
            } else {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
                themeToggle.textContent = 'Toggle Light Mode';
            }
        });

        // Load saved theme
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            document.documentElement.setAttribute('data-theme', 'dark');
            themeToggle.textContent = 'Toggle Light Mode';
        }

        // Initial load
        loadMessages();
    </script>
</body>
</html>
